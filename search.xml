<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView 进阶]]></title>
    <url>%2F2018%2F07%2F06%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[前言现在RecyclerView的应用越来越广泛了，不同的应用场景需要其作出不同的改变。有时候我们可能需要实现侧滑删除的功能，比如知乎首页的侧滑删除，又或者长按Item进行拖动与其他Item进行位置的交换，但RecyclerView没有提供现成的API供我们操作，所幸SDK提供了ItemTouchHelper这样一个工具类帮助我们快速实现以上功能。不多说别的，我们来介绍一下ItemTouchHelper。 什么是ItemTouchHelper12345This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.It works with a RecyclerView and a Callback class, which configures what type of interactions are enabled and also receives events when user performs these actions.Depending on which functionality you support, you should override onMove(RecyclerView, ViewHolder, ViewHolder) and / or onSwiped(ViewHolder, int). 以上是官方文档的介绍，ItemTouchHelper是一个工具类，可实现侧滑删除和拖拽移动，使用这个工具类需要RecyclerView和Callback。同时根据需要重写onMove和onSwiped方法。接下来就来讲述ItemTouchHelper的使用方法。 ItemTouchHelper基本使用方法step.1新建一个接口，让Adapter实现之从解耦的角度考虑，我们需要一个接口来实现Adapter和ItemTouchHelper之间涉及数据的操作，因为ItemTouchHelper在完成触摸的各种动画后，就要对Adapter的数据进行操作，比如侧滑删除操作，最后需要调用Adapter的notifyItemRemove()方法来移除该数据。因此我们可以把数据操作的部分抽象成一个接口方法，让ItemTouchHelper.Callback调用该方法即可。具体如下：新建ItemTouchHelperAdapter:123456public interface ItemTouchHelperAdapter &#123; //数据交换 void onItemMove(int fromPosition,int toPosition); //数据删除 void onItemDissmiss(int position);&#125; 让我们的Adapter实现该接口：12345678910111213141516171819public class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; implements ItemTouchHelperAdapter &#123; //数据 private List&lt;String&gt; mData; ... @Override public void onItemMove(int fromPosition, int toPosition) &#123; //交换位置 Collections.swap(mData,fromPosition,toPosition); notifyItemMoved(fromPosition,toPosition); &#125; @Override public void onItemDissmiss(int position) &#123; //移除数据 mData.remove(position); notifyItemRemoved(position); &#125;&#125; 那么我们在ItemTouchHelper.Callback内直接调用接口的方法即可。 step.2新建类继承自ItemTouchHelper.Callback从官方文档我们知道，使用ItemTouchHelper需要一个Callback，该Callback是ItemTouchHelper.Callback的子类，所以我们需要新建一个类比如SimpleItemTouchHelperCallback继承自ItemTouchHelper.Callback。我们可以重写其数个方法来实现我们的需求。我们先来看看ItemTouchHelper.Callback需要重写的几个常用的方法。 1、public int getMovementFlags(RecyclerView, RecyclerView.ViewHolder)： 该方法用于返回可以滑动的方向，比如说允许从右到左侧滑，允许上下拖动等。我们一般使用makeMovementFlags(int,int)或makeFlag(int, int)来构造我们的返回值。 例如：要使RecyclerView的Item可以上下拖动，同时允许从右到左侧滑，但不许允许从左到右的侧滑，我们可以这样写：123456@Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; //允许上下的拖动 int swipeFlags = ItemTouchHelper.LEFT; //只允许从右向左侧滑 return makeMovementFlags(dragFlags,swipeFlags); &#125; 2、public boolean onMove (RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)当用户拖动一个Item进行上下移动从旧的位置到新的位置的时候会调用该方法，在该方法内，我们可以调用Adapter的notifyItemMoved方法来交换两个ViewHolder的位置，最后返回true，表示被拖动的ViewHolder已经移动到了目的位置。所以，如果要实现拖动交换位置，可以重写该方法（前提是支持上下拖动）： @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) { //onItemMove是接口方法 mAdapter.onItemMove(viewHolder.getAdapterPosition(),target.getAdapterPosition()); return true; } 3、public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction)当用户左右滑动Item达到删除条件时，会调用该方法，一般手指触摸滑动的距离达到RecyclerView宽度的一半时，再松开手指，此时该Item会继续向原先滑动方向滑过去并且调用onSwiped方法进行删除，否则会反向滑回原来的位置。在该方法内部我们可以这样写： @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) { //onItemDissmiss是接口方法 mAdapter.onItemDissmiss(viewHolder.getAdapterPosition()); } 如果在onSwiped方法内我们没有进行任何操作，即不删除已经滑过去的Item，那么就会留下空白的地方，因为实际上该ItemView还占据着该位置，只是移出了我们的可视范围内罢了。 4、public boolean isLongPressDragEnabled()：该方法返回true时，表示支持长按拖动，即长按ItemView后才可以拖动，我们遇到的场景一般也是这样的。默认是返回true。 5、public boolean boolean isItemViewSwipeEnabled()：该方法返回true时，表示如果用户触摸并左右滑动了View，那么可以执行滑动删除操作，即可以调用到onSwiped()方法。默认是返回true。 6、public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState)：从静止状态变为拖拽或者滑动的时候会回调该方法，参数actionState表示当前的状态。 7、public void clearView(RecyclerView recyclerView, ViewHolder viewHolder)：当用户操作完毕某个item并且其动画也结束后会调用该方法，一般我们在该方法内恢复ItemView的初始状态，防止由于复用而产生的显示错乱问题。 8、public void onChildDraw(…)：我们可以在这个方法内实现我们自定义的交互规则或者自定义的动画效果。那么完整的SimpleItemTouchHelperCallback文件是这样的： public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback{ private ItemTouchHelperAdapter mAdapter; public SimpleItemTouchHelperCallback(ItemTouchHelperAdapter adapter){ mAdapter = adapter; } @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; int swipeFlags = ItemTouchHelper.LEFT; return makeMovementFlags(dragFlags,swipeFlags); } @Override public boolean isLongPressDragEnabled() { return true; } @Override public boolean isItemViewSwipeEnabled() { return true; } @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) { mAdapter.onItemMove(viewHolder.getAdapterPosition(),target.getAdapterPosition()); return true; } @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) { mAdapter.onItemDissmiss(viewHolder.getAdapterPosition()); } } step.3为RecycleView添加ItemTouchHelper上面我们修改了Adapter和新建了ItemTouchHelper.Callback的子类，接下来我们要为RecyclerView添加ItemTouchHelper： //先实例化Callback ItemTouchHelper.Callback callback = new SimpleItemTouchHelperCallback(myAdapter); //用Callback构造ItemtouchHelper ItemTouchHelper touchHelper = new ItemTouchHelper(callback); //调用ItemTouchHelper的attachToRecyclerView方法建立联系 touchHelper.attachToRecyclerView(mRecyclerView); 经过以上步骤，我们已经实现了Item的拖拽和侧滑删除功能了，看一下效果： 自定义侧滑动画有时候我们对默认的动画效果可能不满意，需要自己实现想要的动画效果，ItemTouchHelper.Callback提供的onChildDraw方法可以让我们很方便地实现想要的效果。以下带来一种自定义的实现效果，当做抛砖引玉，让大家熟悉自定义效果的运用。先来看看要实现的效果： 该效果是比较常见的，用户向左滑动Item的时候，一开始提示的是“左滑删除”，滑动到一定距离后，显示删除的图标，并且随着滑动距离的增加该图标不断变大，达到最大后用户松开手指，该Item被删除。接下来我们来分析一下怎样实现以上的效果：首先，要想左滑出现一个删除的方块，可以在LinearLayout放一个这样的“方块”，让它与Item水平并排排列，以下是布局文件： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_height="wrap_content" android:layout_width="match_parent" android:orientation="horizontal"&gt; &lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="80dp" android:background="#ffffff" android:layout_marginLeft="4dp" android:layout_marginRight="4dp" android:layout_marginBottom="4dp" app:cardCornerRadius="1dp" app:elevation="1dp" app:contentPadding="1dp"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ffffff"&gt; &lt;TextView android:id="@+id/item" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="22sp" android:padding="4dp" android:layout_centerInParent="true"/&gt; &lt;/RelativeLayout&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;FrameLayout android:layout_width="100dp" android:layout_height="match_parent" android:layout_marginRight="4dp" android:layout_marginBottom="4dp" android:background="#f33213"&gt; &lt;ImageView android:id="@+id/iv_img" android:layout_width="50dp" android:layout_height="50dp" android:layout_gravity="center" android:src="@mipmap/ic_eye_72" android:visibility="invisible"/&gt; &lt;TextView android:id="@+id/tv_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="左滑删除" android:textSize="18sp" android:textColor="#ffffff" android:layout_gravity="center"/&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt; 布局文件修改后，我们尝试来滑动一下，发现后面的删除方块并不会出现，这是因为默认的滑动方式是setTranslationX(int)，即是对整个View的滑动，所以无论我们怎样滑动，都不会出现删除方块。因此，我们要改变一个种滑动方式，比如使用scrollTo(int,int),这种是对View的内容的滑动，所以随着左滑，item会向左滑去，而位于右方的方块自然也就出现了。 接着，我们考虑该“删除眼睛”的图标是怎样从小变大的，这个实现也比较简单，只要根据滑动的距离对该ImageView的LayoutParams.width进行改变就行了，不过要注意限制大小，否则过大会造成图片的失真。当滑动距离等于RecyclerView宽度的一半时，此时松开手会使Item删除，那么我们可以在该滑动距离达到该值时时“眼睛”变得最大，此时可以达到良好的交互效果，提示了用户无需继续滑动即可删除该Item了。 最后我们要考虑的是：在删除了Item或者没删除而滑回原来的位置后，我们要把所做的改变重置一下，否则，会由于RecyclerView的复用而导致其他位置的ViewHolder与当前的ViewHolder所做的改变一样，即造成显示的错误。我们可以在clearView()方法内重置改变，这样就能解决因复用而导致的显示问题了。 最后我们来看看SimpleItemTouchHelperCallback的代码： public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback{ //省略上面的代码.... //限制ImageView长度所能增加的最大值 private double ICON_MAX_SIZE = 50; //ImageView的初始长宽 private int fixedWidth = 150; @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { super.clearView(recyclerView, viewHolder); //重置改变，防止由于复用而导致的显示问题 viewHolder.itemView.setScrollX(0); ((MyAdapter.NormalItem)viewHolder).tv.setText("左滑删除"); FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) ((MyAdapter.NormalItem) viewHolder).iv.getLayoutParams(); params.width = 150; params.height = 150; ((MyAdapter.NormalItem) viewHolder).iv.setLayoutParams(params); ((MyAdapter.NormalItem) viewHolder).iv.setVisibility(View.INVISIBLE); } @Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) { //仅对侧滑状态下的效果做出改变 if (actionState ==ItemTouchHelper.ACTION_STATE_SWIPE){ //如果dX小于等于删除方块的宽度，那么我们把该方块滑出来 if (Math.abs(dX) &lt;= getSlideLimitation(viewHolder)){ viewHolder.itemView.scrollTo(-(int) dX,0); } //如果dX还未达到能删除的距离，此时慢慢增加“眼睛”的大小，增加的最大值为ICON_MAX_SIZE else if (Math.abs(dX) &lt;= recyclerView.getWidth() / 2){ double distance = (recyclerView.getWidth() / 2 -getSlideLimitation(viewHolder)); double factor = ICON_MAX_SIZE / distance; double diff = (Math.abs(dX) - getSlideLimitation(viewHolder)) * factor; if (diff &gt;= ICON_MAX_SIZE) diff = ICON_MAX_SIZE; ((MyAdapter.NormalItem)viewHolder).tv.setText(""); //把文字去掉 ((MyAdapter.NormalItem) viewHolder).iv.setVisibility(View.VISIBLE); //显示眼睛 FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) ((MyAdapter.NormalItem) viewHolder).iv.getLayoutParams(); params.width = (int) (fixWidth + diff); params.height = (int) (fixWidth + diff); ((MyAdapter.NormalItem) viewHolder).iv.setLayoutParams(params); } }else { //拖拽状态下不做改变，需要调用父类的方法 super.onChildDraw(c,recyclerView,viewHolder,dX,dY,actionState,isCurrentlyActive); } } /** * 获取删除方块的宽度 */ public int getSlideLimitation(RecyclerView.ViewHolder viewHolder){ ViewGroup viewGroup = (ViewGroup) viewHolder.itemView; return viewGroup.getChildAt(1).getLayoutParams().width; } } 原文链接：http://tianrongchuang.top/]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path(PathMeasure)]]></title>
    <url>%2F2018%2F07%2F06%2FPathMeasure%2F</url>
    <content type="text"><![CDATA[Path(PathMeasure)前言在Path在UI体系当中不论是在自定义View还是动画，都占有举足轻重的地位。绘制Path，可以通过Android提供的API，或者是贝塞尔曲线、数学函数、图形组合等等方式，而要获取Path上每一个构成点的坐标，一般需要知道Path的函数方法，例如求解贝塞尔曲线上的点的De Casteljau算法，但对于一般的Path来说，是很难通过简单的函数方法来进行计算的，那么，今天需要了解的就是PathMeasure，关于Path测量的运用 PathMeasure今天需要了解的API非常简单，关于Path的测量，我们首先来看一些效果 这种load效果我们经常在项目当中遇见，那么其中有一部分效果是通过测量Path来进行实现的 那么首先我们来看到PathMeasure这个类，那么具体API详细介绍我就列入到下面，今天最主要的核心是，掌握这个类的使用技巧，而不是死板的API，那么我们来首先先看下这个类当中的API 公共方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185public class PathMeasure &#123;private Path mPath;/** * Create an empty PathMeasure object. To uses this to measure the length * of a path, and/or to find the position and tangent along it, call * setPath. * 创建一个空的PathMeasure *用这个构造函数可创建一个空的 PathMeasure， * 但是使用之前需要先调用 setPath 方法来与 Path 进行关联。 * 被关联的 Path 必须是已经创建好的， * 如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. */public PathMeasure() &#123; mPath = null; native_instance = native_create(0, false);&#125;/** * Create a PathMeasure object associated with the specified path object * (already created and specified). The measure object can now return the * path's length, and the position and tangent of any position along the * path. * * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. * 创建 PathMeasure 并关联一个指定的Path(Path需要已经创建完成)。 * 用这个构造函数是创建一个 PathMeasure 并关联一个 Path， * 其实和创建一个空的 PathMeasure 后调用 setPath 进行关联效果是一样的， * 同样，被关联的 Path 也必须是已经创建好的，如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 *该方法有两个参数，第一个参数自然就是被关联的 Path 了， * 第二个参数是用来确保 Path 闭合，如果设置为 true， * 则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)。 * 在这里有两点需要明确: * 1.不论 forceClosed 设置为何种状态(true 或者 false)， * 都不会影响原有Path的状态，即 Path 与 PathMeasure 关联之后，之前的的 Path 不会有任何改变。 * 2.forceClosed 的设置状态可能会影响测量结果， * 如果 Path 未闭合但在与 PathMeasure 关联的时候设置 forceClosed 为 true 时， * 测量结果可能会比 Path 实际长度稍长一点，获取到到是该 Path 闭合时的状态。 * @param path The path that will be measured by this object 被关联的Path * @param forceClosed If true, then the path will be considered as "closed" * even if its contour was not explicitly closed. */public PathMeasure(Path path, boolean forceClosed) &#123; // The native implementation does not copy the path, prevent it from being GC'd mPath = path; native_instance = native_create(path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Assign a new path, or null to have none. * 关联一个Path */public void setPath(Path path, boolean forceClosed) &#123; mPath = path; native_setPath(native_instance, path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Return the total length of the current contour, or 0 if no path is * associated with this measure object. * 返回当前轮廓的总长度，或者如果没有路径，则返回0。与此度量对象相关联。 */public float getLength() &#123; return native_getLength(native_instance);&#125;/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample 位置 * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125;public static final int POSITION_MATRIX_FLAG = 0x01; // must match flags in SkPathMeasure.hpublic static final int TANGENT_MATRIX_FLAG = 0x02; // must match flags in SkPathMeasure.h/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding matrix. Returns false if there is no path, or a zero-length * path was specified, in which case matrix is unchanged. * * @param distance The distance along the associated path * @param matrix Allocated by the caller, this is set to the transformation * associated with the position and tangent at the specified distance * @param flags Specified what aspects should be returned in the matrix. */public boolean getMatrix(float distance, Matrix matrix, int flags) &#123; return native_getMatrix(native_instance, distance, matrix.native_instance, flags);&#125;/** * Given a start and stop distance, return in dst the intervening * segment(s). If the segment is zero-length, return false, else return * true. startD and stopD are pinned to legal values (0..getLength()). * If startD &gt;= stopD then return false (and leave dst untouched). * Begin the segment with a moveTo if startWithMoveTo is true. * * &lt;p&gt;On &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; and earlier * releases, the resulting path may not display on a hardware-accelerated * Canvas. A simple workaround is to add a single operation to this path, * such as &lt;code&gt;dst.rLineTo(0, 0)&lt;/code&gt;.&lt;/p&gt; * 给定启动和停止距离， * 在DST中返回中间段。 * 如果该段为零长度，则返回false， * 否则返回true。 * StestD和Stutd被固定到合法值（0…GigLangTh（））。 * startD&gt;＝stopD，则返回false（并保持DST未被触碰）。 * 如果有一个假设是正确的，就开始以一个模式开始。 * * 早期版本，结果路径可能不会在硬件加速中显示。 * Canvas。 * 一个简单的解决方法是在这个路径中添加一个操作， * 这样的SDST. RLIN to（0, 0） */public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) &#123; // Skia used to enforce this as part of it's API, but has since relaxed that restriction // so to maintain consistency in our API we enforce the preconditions here. float length = getLength(); if (startD &lt; 0) &#123; startD = 0; &#125; if (stopD &gt; length) &#123; stopD = length; &#125; if (startD &gt;= stopD) &#123; return false; &#125; return native_getSegment(native_instance, startD, stopD, dst.mutateNI(), startWithMoveTo);&#125;/** * Return true if the current contour is closed() * 是否闭合 */public boolean isClosed() &#123; return native_isClosed(native_instance);&#125;/** * Move to the next contour in the path. Return true if one exists, or * false if we're done with the path. */public boolean nextContour() &#123; return native_nextContour(native_instance);&#125;protected void finalize() throws Throwable &#123; native_destroy(native_instance); native_instance = 0; // Other finalizers can still call us.&#125;private static native long native_create(long native_path, boolean forceClosed);private static native void native_setPath(long native_instance, long native_path, boolean forceClosed);private static native float native_getLength(long native_instance);private static native boolean native_getPosTan(long native_instance, float distance, float pos[], float tan[]);private static native boolean native_getMatrix(long native_instance, float distance, long native_matrix, int flags);private static native boolean native_getSegment(long native_instance, float startD, float stopD, long native_path, boolean startWithMoveTo);private static native boolean native_isClosed(long native_instance);private static native boolean native_nextContour(long native_instance);private static native void native_destroy(long native_instance);/* package */private long native_instance; 从源码上分析我们可以看得到其实这个类就是为了让我们测量到当前Path所在的位置API不多，那么到底怎么运用呢？首先我们来分析这个效果 很明显我们看到当前这里是一个圆，运用了一张图片，让这张图能够沿着当前的这个圆进行移动那么，这个圆形是我们用Path所绘制的，那么当前Path会记录下当前圆的所有点，而我们需要将那个箭头图片绘制到我们path的点上面，并且按照圆形角度来进行操控而图形是这样的那么这个时候我们能够反映过来，去得到当前图片进行旋转，能够做到这一点， 但是我们如何判断这旋转的角度？ 而测量当中提供了 12345678910111213141516171819/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample PATH起点的长度取值范围: 0 &lt;= distance &lt;= getLength * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125; 那么此时看到这个getPosTan方法其实我们就能够很明显了解到，通过这个方法我们可以根据path的长度值，去取得指定长度所在的XY和切线XY，见下图那么此时能够看到所谓的切线,下面扫盲，段位高跳过几何上，切线指的是一条刚好触碰到曲线上某一点的直线。更准确地说，当切线经过曲线上的某点（即切点）时，切线的方向与曲线上该点的方向是相同的。平面几何中，将和圆只有一个公共交点的直线叫做圆的切线正切函数是直角三角形中，对边与邻边的比值叫做正切。放在直角坐标系中（如图）即 tanθ=y/x而tan就是我们的正切值如上图，参考上图随机选取了一个橙点（具体位置），那么切线是和橙点相交的这条线，切线角度为垂直关系，所以如下图实在不理解TAN的话，你们就理解为当前得到了圆心坐标，因为圆的切线是圆心《建议去复习下初中数学》那么此时，我们拿到的getPosTan方法，能够把当前这个点，和这个点的正切值拿到，我们可以通过反正切计算取得角度,那么橙线和X轴的夹角其实实际上应该是我们到时候显示过去的角度，那么此时，看下图 红线所绘制的角度是我们当前角度，绿线绘制的是需要旋转的角度， 那么我们现在手里拥有的资源是，当前正切值，通过正切值我们运用公式可以计算得到当前角度Math.tan2(tan[1], tan[0]) * 180 / PI 而反切角度的话是Math.atan2(tan[1], tan[0]) * 180 / PI这个就是我们的要移动的角度 那么我们当前上面这个案例就能完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class MyView1 extends View &#123;private float currentValue = 0; // 用于纪录当前的位置,取值范围[0,1]映射Path的整个长度private float[] pos; // 当前点的实际位置private float[] tan; // 当前点的tangent值,用于计算图片所需旋转的角度private Bitmap mBitmap; // 箭头图片private Matrix mMatrix; // 矩阵,用于对图片进行一些操作private Paint mDeafultPaint;private int mViewWidth;private int mViewHeight;private Paint mPaint;public MyView1(Context context) &#123; super(context); init(context);&#125;private void init(Context context) &#123; pos = new float[2]; tan = new float[2]; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 8; // 缩放图片 mBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.arrow, options); mMatrix = new Matrix(); mDeafultPaint = new Paint(); mDeafultPaint.setColor(Color.RED); mDeafultPaint.setStrokeWidth(5); mDeafultPaint.setStyle(Paint.Style.STROKE); mPaint = new Paint(); mPaint.setColor(Color.DKGRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.STROKE);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mViewWidth = w; mViewHeight = h;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.WHITE); // 平移坐标系 canvas.translate(mViewWidth/2,mViewHeight/2); // 画坐标线 canvas.drawLine(-canvas.getWidth(),0,canvas.getWidth(),0,mPaint); canvas.drawLine(0,-canvas.getHeight(),0,canvas.getHeight(),mPaint); Path path = new Path(); // 创建 Path path.addCircle(0, 0, 200, Path.Direction.CW); // 添加一个圆形 Log.i("barry","----------------------pos[0] = " + pos[0] + "pos[1] = " +pos[1]); Log.i("barry","----------------------tan[0] = " + tan[0] + "tan[1] = " +tan[1]); PathMeasure measure = new PathMeasure(path, false); // 创建 PathMeasure currentValue += 0.005; // 计算当前的位置在总长度上的比例[0,1] if (currentValue &gt;= 1) &#123; currentValue = 0; &#125; // 方案一 // 获取当前位置的坐标以及趋势 measure.getPosTan(measure.getLength() * currentValue, pos, tan); canvas.drawCircle(tan[0],tan[1],20,mDeafultPaint); // 重置Matrix mMatrix.reset(); // 计算图片旋转角度 float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // 旋转图片 mMatrix.postRotate(degrees, mBitmap.getWidth() / 2, mBitmap.getHeight() / 2); // 将图片绘制中心调整到与当前点重合 mMatrix.postTranslate(pos[0] - mBitmap.getWidth() / 2, pos[1] - mBitmap.getHeight() / 2); // 方案二 // 获取当前位置的坐标以及趋势的矩阵 //measure.getMatrix(measure.getLength() * currentValue, mMatrix, //PathMeasure.TANGENT_MATRIX_FLAG | PathMeasure.POSITION_MATRIX_FLAG); // 将图片绘制中心调整到与当前点重合(注意:此处是前乘pre) //mMatrix.preTranslate(-mBitmap.getWidth() / 2, -mBitmap.getHeight() / 2); canvas.drawPath(path, mDeafultPaint); canvas.drawBitmap(mBitmap, mMatrix, mDeafultPaint); invalidate();&#125;&#125; 那么其他API基础使用大家可以参考网上的说明，以及文档资料.]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2018%2F07%2F06%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[前言相信很多同学都知道“[贝塞尔曲线]”这个词，我们在很多地方都能经常看到。但是，可能并不是每位同学都清楚地知道，到底什么是“贝塞尔曲线”，又是什么特点让它有这么高的知名度。 贝塞尔曲线的数学基础是早在 1912 年就广为人知的[伯恩斯坦多项式]。但直到 1959 年，当时就职于雪铁龙的法国数学家 [Paul de Casteljau]才开始对它进行图形化应用的尝试，并提出了一种数值稳定的 [de Casteljau 算法]。然而贝塞尔曲线的得名，却是由于 1962 年另一位就职于雷诺的法国工程师 [Pierre Bézier]的广泛宣传。他使用这种只需要很少的控制点就能够生成复杂平滑曲线的方法，来辅助汽车车体的工业设计。 正是因为控制简便却具有极强的描述能力，贝塞尔曲线在工业设计领域迅速得到了广泛的应用。不仅如此，在计算机图形学领域，尤其是矢量图形学，贝塞尔曲线也占有重要的地位。今天我们最常见的一些矢量绘图软件，如 Flash、Illustrator、CorelDraw 等，无一例外都提供了绘制贝塞尔曲线的功能。甚至像 Photoshop 这样的位图编辑软件，也把贝塞尔曲线作为仅有的矢量绘制工具（钢笔工具）包含其中。 贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具，如PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。 好吧，我承认上面是一组废话， 来源于百科，那么其实想要真正了解什么是贝塞尔曲线，我们首先来明白他到底是什么， 贝塞尔曲线详解本质概念：一组算法目的：这组算法用来干什么？核心：通过这组算法，我门能达到什么效果 那么首先我门来看最基础的一介贝塞尔 一介贝塞尔 一阶贝塞尔曲线的核心目的其实就只是由两点控制的一条直线 二阶贝塞尔曲线是由一个控制点去控制一条的曲线,而曲线的运动是由两个直线所控制 二介贝塞尔绘制过程image.png那么这里相信有很多同学对于上图比较的懵，接下来我们将上图拆解出来分析 image.png那么此时贝塞尔曲线的计算规则是由A-C &amp; B-C进行连线 image.png然后在AC线段和BC线段进行等比定位 画的不是太标准，但是AC CB 定位点的位置的比例需要一致然后由AC上的点和CB上的点进行连接，在选取这条线段上同AC CB比例相同的点 image.png那么这个点就是绘制贝塞尔曲线的点 image.png我们的整条曲线是从AC线段开始绘制，通过Path路径进行绘制，如下图 二介贝塞尔绘制过程那么此时如果你还不明白，或者是你们受不了我的图纸了，那么看下面 实际线条是从A开始到C结束绘制过程由A点开始，例：D点和A点成一个百分比那么这里BC线段上同样出现BE这两个点，百分比和AD一致在经由这两个点连线出现DE这条线，那么在从这条线上面取得同AD,BE的比例的点F那么当前这个点就是当前绘制的这一个点我们由A-C开始启动绘制，用PATH记录点进行绘制，从而得到一条曲线，这条曲线就是我们的贝塞尔曲线PS:哎，如果在这里才懂得同学你们就让我伤心了，果然还是别人画的图比我画的好看。 那么此时其实我们对于之前的在百度百科上看到的贝塞尔算法 二阶算法.png 三阶算法.png这种算法可以直接忽略了，因为看的蛋疼 我们直接通过下图得出]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
      </tags>
  </entry>
</search>
