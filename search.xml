<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2F2018%2F07%2F06%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[前言相信很多同学都知道“[贝塞尔曲线]”这个词，我们在很多地方都能经常看到。但是，可能并不是每位同学都清楚地知道，到底什么是“贝塞尔曲线”，又是什么特点让它有这么高的知名度。 贝塞尔曲线的数学基础是早在 1912 年就广为人知的[伯恩斯坦多项式]。但直到 1959 年，当时就职于雪铁龙的法国数学家 [Paul de Casteljau]才开始对它进行图形化应用的尝试，并提出了一种数值稳定的 [de Casteljau 算法]。然而贝塞尔曲线的得名，却是由于 1962 年另一位就职于雷诺的法国工程师 [Pierre Bézier]的广泛宣传。他使用这种只需要很少的控制点就能够生成复杂平滑曲线的方法，来辅助汽车车体的工业设计。 正是因为控制简便却具有极强的描述能力，贝塞尔曲线在工业设计领域迅速得到了广泛的应用。不仅如此，在计算机图形学领域，尤其是矢量图形学，贝塞尔曲线也占有重要的地位。今天我们最常见的一些矢量绘图软件，如 Flash、Illustrator、CorelDraw 等，无一例外都提供了绘制贝塞尔曲线的功能。甚至像 Photoshop 这样的位图编辑软件，也把贝塞尔曲线作为仅有的矢量绘制工具（钢笔工具）包含其中。 贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具，如PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。 好吧，我承认上面是一组废话， 来源于百科，那么其实想要真正了解什么是贝塞尔曲线，我们首先来明白他到底是什么， 贝塞尔曲线详解本质概念：一组算法目的：这组算法用来干什么？核心：通过这组算法，我门能达到什么效果 那么首先我门来看最基础的一介贝塞尔 一介贝塞尔 一阶贝塞尔曲线的核心目的其实就只是由两点控制的一条直线 二阶贝塞尔曲线是由一个控制点去控制一条的曲线,而曲线的运动是由两个直线所控制 二介贝塞尔绘制过程image.png那么这里相信有很多同学对于上图比较的懵，接下来我们将上图拆解出来分析 image.png那么此时贝塞尔曲线的计算规则是由A-C &amp; B-C进行连线 image.png然后在AC线段和BC线段进行等比定位 画的不是太标准，但是AC CB 定位点的位置的比例需要一致然后由AC上的点和CB上的点进行连接，在选取这条线段上同AC CB比例相同的点 image.png那么这个点就是绘制贝塞尔曲线的点 image.png我们的整条曲线是从AC线段开始绘制，通过Path路径进行绘制，如下图 二介贝塞尔绘制过程那么此时如果你还不明白，或者是你们受不了我的图纸了，那么看下面 实际线条是从A开始到C结束绘制过程由A点开始，例：D点和A点成一个百分比那么这里BC线段上同样出现BE这两个点，百分比和AD一致在经由这两个点连线出现DE这条线，那么在从这条线上面取得同AD,BE的比例的点F那么当前这个点就是当前绘制的这一个点我们由A-C开始启动绘制，用PATH记录点进行绘制，从而得到一条曲线，这条曲线就是我们的贝塞尔曲线PS:哎，如果在这里才懂得同学你们就让我伤心了，果然还是别人画的图比我画的好看。 那么此时其实我们对于之前的在百度百科上看到的贝塞尔算法 二阶算法.png 三阶算法.png这种算法可以直接忽略了，因为看的蛋疼 我们直接通过下图得出]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path(PathMeasure)]]></title>
    <url>%2F2018%2F07%2F05%2FPathMeasure%2F</url>
    <content type="text"><![CDATA[Path(PathMeasure)前言在Path在UI体系当中不论是在自定义View还是动画，都占有举足轻重的地位。绘制Path，可以通过Android提供的API，或者是贝塞尔曲线、数学函数、图形组合等等方式，而要获取Path上每一个构成点的坐标，一般需要知道Path的函数方法，例如求解贝塞尔曲线上的点的De Casteljau算法，但对于一般的Path来说，是很难通过简单的函数方法来进行计算的，那么，今天需要了解的就是PathMeasure，关于Path测量的运用 PathMeasure今天需要了解的API非常简单，关于Path的测量，我们首先来看一些效果 这种load效果我们经常在项目当中遇见，那么其中有一部分效果是通过测量Path来进行实现的 那么首先我们来看到PathMeasure这个类，那么具体API详细介绍我就列入到下面，今天最主要的核心是，掌握这个类的使用技巧，而不是死板的API，那么我们来首先先看下这个类当中的API 公共方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185public class PathMeasure &#123;private Path mPath;/** * Create an empty PathMeasure object. To uses this to measure the length * of a path, and/or to find the position and tangent along it, call * setPath. * 创建一个空的PathMeasure *用这个构造函数可创建一个空的 PathMeasure， * 但是使用之前需要先调用 setPath 方法来与 Path 进行关联。 * 被关联的 Path 必须是已经创建好的， * 如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. */public PathMeasure() &#123; mPath = null; native_instance = native_create(0, false);&#125;/** * Create a PathMeasure object associated with the specified path object * (already created and specified). The measure object can now return the * path's length, and the position and tangent of any position along the * path. * * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. * 创建 PathMeasure 并关联一个指定的Path(Path需要已经创建完成)。 * 用这个构造函数是创建一个 PathMeasure 并关联一个 Path， * 其实和创建一个空的 PathMeasure 后调用 setPath 进行关联效果是一样的， * 同样，被关联的 Path 也必须是已经创建好的，如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 *该方法有两个参数，第一个参数自然就是被关联的 Path 了， * 第二个参数是用来确保 Path 闭合，如果设置为 true， * 则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)。 * 在这里有两点需要明确: * 1.不论 forceClosed 设置为何种状态(true 或者 false)， * 都不会影响原有Path的状态，即 Path 与 PathMeasure 关联之后，之前的的 Path 不会有任何改变。 * 2.forceClosed 的设置状态可能会影响测量结果， * 如果 Path 未闭合但在与 PathMeasure 关联的时候设置 forceClosed 为 true 时， * 测量结果可能会比 Path 实际长度稍长一点，获取到到是该 Path 闭合时的状态。 * @param path The path that will be measured by this object 被关联的Path * @param forceClosed If true, then the path will be considered as "closed" * even if its contour was not explicitly closed. */public PathMeasure(Path path, boolean forceClosed) &#123; // The native implementation does not copy the path, prevent it from being GC'd mPath = path; native_instance = native_create(path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Assign a new path, or null to have none. * 关联一个Path */public void setPath(Path path, boolean forceClosed) &#123; mPath = path; native_setPath(native_instance, path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Return the total length of the current contour, or 0 if no path is * associated with this measure object. * 返回当前轮廓的总长度，或者如果没有路径，则返回0。与此度量对象相关联。 */public float getLength() &#123; return native_getLength(native_instance);&#125;/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample 位置 * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125;public static final int POSITION_MATRIX_FLAG = 0x01; // must match flags in SkPathMeasure.hpublic static final int TANGENT_MATRIX_FLAG = 0x02; // must match flags in SkPathMeasure.h/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding matrix. Returns false if there is no path, or a zero-length * path was specified, in which case matrix is unchanged. * * @param distance The distance along the associated path * @param matrix Allocated by the caller, this is set to the transformation * associated with the position and tangent at the specified distance * @param flags Specified what aspects should be returned in the matrix. */public boolean getMatrix(float distance, Matrix matrix, int flags) &#123; return native_getMatrix(native_instance, distance, matrix.native_instance, flags);&#125;/** * Given a start and stop distance, return in dst the intervening * segment(s). If the segment is zero-length, return false, else return * true. startD and stopD are pinned to legal values (0..getLength()). * If startD &gt;= stopD then return false (and leave dst untouched). * Begin the segment with a moveTo if startWithMoveTo is true. * * &lt;p&gt;On &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; and earlier * releases, the resulting path may not display on a hardware-accelerated * Canvas. A simple workaround is to add a single operation to this path, * such as &lt;code&gt;dst.rLineTo(0, 0)&lt;/code&gt;.&lt;/p&gt; * 给定启动和停止距离， * 在DST中返回中间段。 * 如果该段为零长度，则返回false， * 否则返回true。 * StestD和Stutd被固定到合法值（0…GigLangTh（））。 * startD&gt;＝stopD，则返回false（并保持DST未被触碰）。 * 如果有一个假设是正确的，就开始以一个模式开始。 * * 早期版本，结果路径可能不会在硬件加速中显示。 * Canvas。 * 一个简单的解决方法是在这个路径中添加一个操作， * 这样的SDST. RLIN to（0, 0） */public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) &#123; // Skia used to enforce this as part of it's API, but has since relaxed that restriction // so to maintain consistency in our API we enforce the preconditions here. float length = getLength(); if (startD &lt; 0) &#123; startD = 0; &#125; if (stopD &gt; length) &#123; stopD = length; &#125; if (startD &gt;= stopD) &#123; return false; &#125; return native_getSegment(native_instance, startD, stopD, dst.mutateNI(), startWithMoveTo);&#125;/** * Return true if the current contour is closed() * 是否闭合 */public boolean isClosed() &#123; return native_isClosed(native_instance);&#125;/** * Move to the next contour in the path. Return true if one exists, or * false if we're done with the path. */public boolean nextContour() &#123; return native_nextContour(native_instance);&#125;protected void finalize() throws Throwable &#123; native_destroy(native_instance); native_instance = 0; // Other finalizers can still call us.&#125;private static native long native_create(long native_path, boolean forceClosed);private static native void native_setPath(long native_instance, long native_path, boolean forceClosed);private static native float native_getLength(long native_instance);private static native boolean native_getPosTan(long native_instance, float distance, float pos[], float tan[]);private static native boolean native_getMatrix(long native_instance, float distance, long native_matrix, int flags);private static native boolean native_getSegment(long native_instance, float startD, float stopD, long native_path, boolean startWithMoveTo);private static native boolean native_isClosed(long native_instance);private static native boolean native_nextContour(long native_instance);private static native void native_destroy(long native_instance);/* package */private long native_instance; 从源码上分析我们可以看得到其实这个类就是为了让我们测量到当前Path所在的位置API不多，那么到底怎么运用呢？首先我们来分析这个效果 很明显我们看到当前这里是一个圆，运用了一张图片，让这张图能够沿着当前的这个圆进行移动那么，这个圆形是我们用Path所绘制的，那么当前Path会记录下当前圆的所有点，而我们需要将那个箭头图片绘制到我们path的点上面，并且按照圆形角度来进行操控而图形是这样的那么这个时候我们能够反映过来，去得到当前图片进行旋转，能够做到这一点， 但是我们如何判断这旋转的角度？ 而测量当中提供了 12345678910111213141516171819/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample PATH起点的长度取值范围: 0 &lt;= distance &lt;= getLength * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125; 那么此时看到这个getPosTan方法其实我们就能够很明显了解到，通过这个方法我们可以根据path的长度值，去取得指定长度所在的XY和切线XY，见下图那么此时能够看到所谓的切线,下面扫盲，段位高跳过几何上，切线指的是一条刚好触碰到曲线上某一点的直线。更准确地说，当切线经过曲线上的某点（即切点）时，切线的方向与曲线上该点的方向是相同的。平面几何中，将和圆只有一个公共交点的直线叫做圆的切线正切函数是直角三角形中，对边与邻边的比值叫做正切。放在直角坐标系中（如图）即 tanθ=y/x而tan就是我们的正切值如上图，参考上图随机选取了一个橙点（具体位置），那么切线是和橙点相交的这条线，切线角度为垂直关系，所以如下图实在不理解TAN的话，你们就理解为当前得到了圆心坐标，因为圆的切线是圆心《建议去复习下初中数学》那么此时，我们拿到的getPosTan方法，能够把当前这个点，和这个点的正切值拿到，我们可以通过反正切计算取得角度,那么橙线和X轴的夹角其实实际上应该是我们到时候显示过去的角度，那么此时，看下图 红线所绘制的角度是我们当前角度，绿线绘制的是需要旋转的角度， 那么我们现在手里拥有的资源是，当前正切值，通过正切值我们运用公式可以计算得到当前角度Math.tan2(tan[1], tan[0]) * 180 / PI 而反切角度的话是Math.atan2(tan[1], tan[0]) * 180 / PI这个就是我们的要移动的角度 那么我们当前上面这个案例就能完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class MyView1 extends View &#123;private float currentValue = 0; // 用于纪录当前的位置,取值范围[0,1]映射Path的整个长度private float[] pos; // 当前点的实际位置private float[] tan; // 当前点的tangent值,用于计算图片所需旋转的角度private Bitmap mBitmap; // 箭头图片private Matrix mMatrix; // 矩阵,用于对图片进行一些操作private Paint mDeafultPaint;private int mViewWidth;private int mViewHeight;private Paint mPaint;public MyView1(Context context) &#123; super(context); init(context);&#125;private void init(Context context) &#123; pos = new float[2]; tan = new float[2]; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 8; // 缩放图片 mBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.arrow, options); mMatrix = new Matrix(); mDeafultPaint = new Paint(); mDeafultPaint.setColor(Color.RED); mDeafultPaint.setStrokeWidth(5); mDeafultPaint.setStyle(Paint.Style.STROKE); mPaint = new Paint(); mPaint.setColor(Color.DKGRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.STROKE);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mViewWidth = w; mViewHeight = h;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.WHITE); // 平移坐标系 canvas.translate(mViewWidth/2,mViewHeight/2); // 画坐标线 canvas.drawLine(-canvas.getWidth(),0,canvas.getWidth(),0,mPaint); canvas.drawLine(0,-canvas.getHeight(),0,canvas.getHeight(),mPaint); Path path = new Path(); // 创建 Path path.addCircle(0, 0, 200, Path.Direction.CW); // 添加一个圆形 Log.i("barry","----------------------pos[0] = " + pos[0] + "pos[1] = " +pos[1]); Log.i("barry","----------------------tan[0] = " + tan[0] + "tan[1] = " +tan[1]); PathMeasure measure = new PathMeasure(path, false); // 创建 PathMeasure currentValue += 0.005; // 计算当前的位置在总长度上的比例[0,1] if (currentValue &gt;= 1) &#123; currentValue = 0; &#125; // 方案一 // 获取当前位置的坐标以及趋势 measure.getPosTan(measure.getLength() * currentValue, pos, tan); canvas.drawCircle(tan[0],tan[1],20,mDeafultPaint); // 重置Matrix mMatrix.reset(); // 计算图片旋转角度 float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // 旋转图片 mMatrix.postRotate(degrees, mBitmap.getWidth() / 2, mBitmap.getHeight() / 2); // 将图片绘制中心调整到与当前点重合 mMatrix.postTranslate(pos[0] - mBitmap.getWidth() / 2, pos[1] - mBitmap.getHeight() / 2); // 方案二 // 获取当前位置的坐标以及趋势的矩阵 //measure.getMatrix(measure.getLength() * currentValue, mMatrix, //PathMeasure.TANGENT_MATRIX_FLAG | PathMeasure.POSITION_MATRIX_FLAG); // 将图片绘制中心调整到与当前点重合(注意:此处是前乘pre) //mMatrix.preTranslate(-mBitmap.getWidth() / 2, -mBitmap.getHeight() / 2); canvas.drawPath(path, mDeafultPaint); canvas.drawBitmap(mBitmap, mMatrix, mDeafultPaint); invalidate();&#125;&#125; 那么其他API基础使用大家可以参考网上的说明，以及文档资料.]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
      </tags>
  </entry>
</search>
